# 现代集成电路分析方法 Project 1

23212020011 罗咏瀚 2023年12月16日

## 文件结构

主目录为myspice/，重新编排了提供的示例代码，使用Cmake编译，在windows和linux系统下都可以使用。  

* /benchmark 测试使用的网表和输出结果
* /bin 编译出的可执行文件
* /build 用Cmake生成的相关文件
* /include 头文件
* /src 源文件
* CMakeLists.txt
* README.md

## 运行方式

```text
myspice -f xxx.sp
```

## 程序说明

目前对子电路的支持还不完全（可读取至数据结构中，但还不能加入到矩阵中）。  
_C、_G、_B和_LT矩阵使用稀疏CSR格式存储和输出，加入元素时先添加至缓冲区，全部元素加入后再生成CSR。  
_X、_Y、_U使用字符串数组的方式存储和输出。  
例如spicets.out文件内容如下（增加了注释以及空行）：  

```text
// 以下三行分别是_C矩阵的row_pointer、column_index和value
0 0 0 1 1 1 2 
2 5 
2.000000 0.500000 

// 以下三行分别是_G矩阵的row_pointer、column_index和value
0 3 5 8 11 13 14 
0 2 5 1 3 0 2 4 1 3 4 2 3 0 
0.000333 -0.000333 -1.000000 0.000656 -0.000556 -0.000333 0.000333 1.000000 -0.000556 0.000556 -1.000000 -1.000000 1.000000 1.000000 

// 以下三行分别是_B矩阵的row_pointer、column_index和value
0 1 3 4 4 5 5 
0 0 1 1 2 
0.002000 -0.002000 -0.005000 0.005000 1.000000 

// 以下三行分别是_LT矩阵的row_pointer、column_index和value
0 1 2 
2 1 
1.000000 1.000000 

// _X，即所有未知量，默认为结点电压，前面加i的是辅助电流
N_IN1 N_IN4 N_IN2 N_IN3 i:VS3 i:L1 

// _Y，即Probe的变量
N_IN2 N_IN4 

// _U，即所有的电流/电压源
IS1 IS2 VS3 
```

由于排序方式不同，最终矩阵会与标准答案不一致。

## 程序编写思路

主要写一写实现思路，包括已经完成的和未完成的，方便后续继续补充。  

程序主体很简单，只有parse、setup和output三个部分。  

在parse阶段，主要沿用了参考代码，将网表信息读入到数据结构中。但是为了支持子电路，可能需要递归的特性（考虑到子电路中可能包含其他子电路），因此把parse一行的操作独立为一个函数，便于递归调用。一个比较麻烦的地方在于，我们可能需要子电路的层次信息，例如子电路A的实例A1中的子电路B的实例B1中的电阻R1，在最终表示时应该写为A1:B1:R1，也就是需要保留上面层次的信息，此外也需要避免递归定义的问题（子电路A包含子电路B，但子电路B由包含子电路A，那么这两个子电路大小都是无穷大），这样的话最好使用栈的数据结构进行parse过程。但目前还没这么实现，而是默认子电路中不会再包含子电路。  

在parse阶段，对于子电路的处理方式，我们选择在读到子电路实例时，把它当做一个独立的普通元器件，在读到子电路定义时，将对应的数据读入到特殊的数据结构中（SubcktDef类），需要展开时就进行查询，然后将对应端口、内部结点展开。  

最后，parse阶段还能直接得到_Y向量，直接使用字符串存储。  

在setup阶段，第一步是计算最终矩阵大小，即未知数的数量，显然还是需要考虑子电路的变量数，好在此时所有子电路的定义都已经读取完毕，使用类似DFS的方式计算所有子电路的未知数数量就可以了（如果内部有全局结点，那就减去相应的数量），这一部分的代码已经完成，但是还没加进setup阶段中，因为会遇到更加麻烦的变量排序问题。  

setup的第二步是生成_X向量，这里用字符串存储的原因是方便输出，以及转换为编号也通过字典简单地实现。此时_X和_Y都已知，因此_LT也可以直接得到。  

setup的第三步是对各电路元件进行stamp，这一步会生成_C、_G、_B以及_U。

setup的三步完成之后，所有需要打印的信息就都准备好了，调用mat::csr()正式形成四个矩阵的稀疏格式，然后就可以在output阶段输出了。  

在整个过程中保持变量顺序是比较麻烦的，在目前的代码中，在不考虑子电路的情况下，分析电路过程中增加的辅助变量总会出现在最后（即矩阵的右下角），使得最终矩阵具有分块的特点。如果要考虑子电路，情况也是类似的，需要统计每个子电路中的正常结点数量与辅助结点数量。  
